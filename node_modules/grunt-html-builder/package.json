{
  "name": "grunt-html-builder",
  "description": "Build HTML sites",
  "version": "0.5.8",
  "homepage": "https://github.com/aaaristo/grunt-html-builder",
  "author": {
    "name": "Andrea Amerigo Aristodemo Gariboldi",
    "url": "https://github.com/aaaristo"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/aaaristo/grunt-html-builder"
  },
  "bugs": {
    "url": "https://github.com/aaaristo/grunt-html-builder/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/aaaristo/grunt-html-builder/blob/master/LICENSE-MIT"
    }
  ],
  "main": "Gruntfile.js",
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "test": "grunt test --stack"
  },
  "dependencies": {
    "cheerio": "~0.13.1",
    "JSONPath": "~0.9.1",
    "xmlbuilder": "~0.4.2",
    "node-zip": "~1.0.1",
    "optimist": "~0.4.0",
    "request": "~2.21.0",
    "commander": "~1.3.2",
    "pkginfo": "~0.3.0",
    "xmldom": "~0.1.16",
    "msgpack": "~0.2.2"
  },
  "devDependencies": {
    "grunt-contrib-jshint": "~0.2.0",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt": "~0.4.0",
    "grunt-contrib-watch": "~0.3.0",
    "node-zip": "~1.0.1",
    "optimist": "~0.4.0"
  },
  "peerDependencies": {
    "grunt": "~0.4.0"
  },
  "keywords": [
    "gruntplugin"
  ],
  "readme": "# grunt-html-builder [![Build Status](https://secure.travis-ci.org/aaaristo/grunt-html-builder.png?branch=master)](http://travis-ci.org/aaaristo/grunt-html-builder) [![Stories in Ready](https://badge.waffle.io/aaaristo/grunt-html-builder.png)](http://waffle.io/aaaristo/grunt-html-builder)\n\nAssemble static HTML files in parallel using jquery, jsrender and *child_process* nodejs module,\nstarting from json (and xlsx) files to describe data (products, people... etc),\nall integrated in a maven like build lifecycle based on conventions against configuration.\n\nActually we build a medium complexity site of ~4500 pages in ~120secs on a quad-core iMac,\nwith SSD.\nThe same site built on an High-IO EC2 instance takes ~60secs for generation.\nBy default we launch a builder for each core we detect so that they can build\npages in parallel.\n\n***NOTE:*** as of 0.5.0, we dropped JSDOM to use [cheerio](https://github.com/MatthewMueller/cheerio),\nand generated a complex site of 11208 pages on an AWS EC2 i2.8xlarge in 24secs. \nUnfortunately cheerio does not support pseudo selectors like :eq, :odd, :even,\nbut you can use the function version like this: $(..).eq(1) or $(..).odd()...\n\n## Why?\n\nBuilding web sites often you find your self using a CMS,\nintegrating it with some legacy/es, tuning web servers, application servers, databases,\nand when it is not enough, go back to the code and squeeze anything you can, and put some kind \nof caching around, often more than one type, and of course\nkeep those caches in sync. This is a pretty full contact sport.\n\nThe thing i always noticed doing that is that all this work often is about producing\na file or memory buffer (depending on wich caching type you use) containing the content \nbeing actually served to the user.\n\nSo the typical runtime flow of a MISS request would be:\n\nuser request > build the buffer hocus pocus > cache > response\n\nThis is really about having users pull your pages. Why dont'we push\nthe site to the user?\n\ndo the hocus pocus/integrations batch > put pages on a CDN near the user < have the user acces things fast\n\nObviously not all sites may be done like that, but many could, saving you a lot of time.\n\n## Getting Started\nInstall this grunt plugin next to your project'\n\nThen add this line to your project's `Gruntfile.js` gruntfile:\n\n```javascript\ngrunt.loadNpmTasks('grunt-html-builder');\n```\n\n[grunt]: http://gruntjs.com/\n\n## Documentation\n\nThe simplest way to get started is:\n<pre>\n$ git clone git://github.com/aaaristo/html-builder-sample.git\n</pre>\n\nThis will bring you a preconfigured project with most common options,\nthat contains 4 files:\n<pre>\n$ find ./ -type f\n./Gruntfile.js\n./package.json\n./README.md\n./src/js/page/home.js\n</pre>\n\nLet's skip the *Gruntfile.js* for the moment. (as usal it contains various grunt tasks configurations) \n\nLooking at the package.json you can see which dependencies will be installed \nto make the thing work:\n```javascript\n{\n   ...\n\n  \"devDependencies\": {\n    \"grunt\": \"~0.4.0\",\n    \"grunt-contrib-watch\": \"~0.3.1\",\n    \"grunt-contrib-clean\": \"~0.4.0\",\n    \"grunt-contrib-connect\": \"~0.2.0\",\n    \"grunt-html-builder\": \"~0.4.20\",\n    \"grunt-contrib-copy\": \"~0.4.0\",\n    \"grunt-s3\": \"~0.2.0-alpha.1\",\n    \"grunt-cloudfront-clear\": \"0.0.1\",\n    \"grunt-contrib-compass\": \"~0.2.0\"\n  },\n\n   ...\n}\n```\n\nNow you have to run *npm install* from the project directory to install those dependencies.\n\nOnce you get the dependencies installed you can finally run *grunt*\nand you should see somenthing like:\n\n<pre>\nRunning \"html-builder-json\" task\n\nRunning \"html-builder\" task\n>> Evaluating home.js...\n>> Launching builders...\n>> builder[0]: inited\n>> builder[0]: Generated page dist/index.html\n\nRunning \"copy:client\" (copy) task\n\n\nDone, without errors.\n</pre>\n\nNice, what happened is that html-builder found a file *home.js*\nunder the directory *src/js/page*, containing only this line of javascript:\n\n```javascript\npage({ path: 'index' });\n```\nThe *page* function tells the builder to produce a page that is described \nby the object passed as parameter, actually we are telling the builder \nwe want a page called index.html, and the page is created under the *dist*\ndirectory inside of your project. So now you should have a *dist/index.html*\nthat look like this:\n\n```html\n<!DOCTYPE html>\n<html>\n   <head>\n      <title>Test site</title>\n   </head>\n   <body>\n   </body>\n</html>\n```\n\nNot so impressive... This is the base html created by the builder,\nand you can but you can completely adjust as you wish by creating a\nfile *src/html/html.html*, let's suppose with H5BP http://html5boilerplate.com/:\n\n```html\n<!DOCTYPE html>\n<!--[if lt IE 7]>      <html class=\"no-js lt-ie9 lt-ie8 lt-ie7\"> <![endif]-->\n<!--[if IE 7]>         <html class=\"no-js lt-ie9 lt-ie8\"> <![endif]-->\n<!--[if IE 8]>         <html class=\"no-js lt-ie9\"> <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\"> <!--<![endif]-->\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n        <title></title>\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width\">\n\n        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->\n\n        <link rel=\"stylesheet\" href=\"/css/normalize.css\">\n        <link rel=\"stylesheet\" href=\"/css/main.css\">\n        <script src=\"/js/vendor/modernizr-2.6.2.min.js\"></script>\n    </head>\n    <body>\n        <!--[if lt IE 7]>\n            <p class=\"chromeframe\">You are using an <strong>outdated</strong> browser. Please <a href=\"http://browsehappy.com/\">upgrade your browser</a> or <a href=\"http://www.google.com/chromeframe/?redirect=true\">activate Google Chrome Frame</a> to improve your experience.</p>\n        <![endif]-->\n\n        <!-- Add your site or application content here -->\n        <p>Hello world! This is HTML5 Boilerplate.</p>\n\n        <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"></script>\n        <script>window.jQuery || document.write('<script src=\"js/vendor/jquery-1.9.1.min.js\"><\\/script>')</script>\n        <script src=\"/js/plugins.js\"></script>\n        <script src=\"/js/main.js\"></script>\n\n        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->\n        <script>\n            var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];\n            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];\n            g.src='//www.google-analytics.com/ga.js';\n            s.parentNode.insertBefore(g,s)}(document,'script'));\n        </script>\n    </body>\n</html>\n```\nRerun *grunt* and try the site with *grunt listen* (grunt-contrib-connect + grunt-contrib-watch). \nOk now we have nice html but we miss some resources, right?\nSo create the *src/client/* directory so that you have a root\nfor files that have to be accessed by the browser and place H5BP\nresources in there like this:\n\n<pre>\nsrc/client\nsrc/client/css\nsrc/client/css/main.css\nsrc/client/css/normalize.css\nsrc/client/img\nsrc/client/img/.gitignore\nsrc/client/js\nsrc/client/js/main.js\nsrc/client/js/plugins.js\nsrc/client/js/vendor\nsrc/client/js/vendor/jquery-1.9.1.min.js\nsrc/client/js/vendor/modernizr-2.6.2.min.js\n</pre>\n\nand if you don't have the *grunt listen* running give it a *grunt client*\nto make grunt copy the files and directories under *src/client* to the\n*dist* directory. Now once you have the *grunt listen* active the are kept\nin sync by grunt (grunt-contrib-watch + grunt-contrib-copy). The same\nis true for page generation... Try to edit the html.html file and see the results\non your browser by refreshing the page.\n\nOk, probably you have a more complex site to build than this, so lets take\na look at how the builder builds your pages:\n\n* as seen it uses the *src/html/html.html* to start (or a default html if it is not provided)\n* it goes throught all the files in *src/js/page* to understand which pages to build\n* your files tell him how many pages to build by simply calling the *page* function many times,\n   to experiment try to change the *home.js* file to read:\n   \n   ```javascript\n   _(100).times(function (i)\n   {\n      page({ path: 'index'+i });\n   });\n   ```\n   \n   yes... it dumbly creates 100 pages. But you now know you can use underscore.js in those files\n   by default, and that the path attribute tells the builder which html files to create. There is\n   another thing to note: all those pages from now on are of the same type for the builder, the type\n   is a machine name given by the name of the js file that asks the creation of a page, in this case\n   *home* type. So yes probably the home.js in almost any site will call the page function 1 time (so \n   revert this dumb thing).\n\n* Now lets suppose you want to create a page for every people in your company, create a \n   *src/js/page/person.js* like this:\n\n```javascript\n['John','Jane','Dave','Mike']\n.forEach(function (person)\n{\n   page({ path: 'person/'+person.toLowerCase(), title: person });\n});\n```\n   so ok you got it... Open html.html and replace the content of the title tag to read: \n\n```html\n<title>{{>title}}'s page</title>\n```\n\n   almost any html is a jsrender template the html.html renders the page object by default,\n   so that you can use it to store the page title / meta description, etc... But this is not\n   ment to create entire pages.\n\n * Instead you can instruct the builder to use a *layout* for your pages so that you can benefit\n   from splitting the page in many *regions*. For example lets suppose you want a *sidebar* region to\n   navigate between your peoples, and a *content* region to represent a people. Now you can create this \n   *layout* by creating file *src/html/layout/sidebar.html* like this:\n\n```html\n\n<aside data-region=\"sidebar\"></aside>\n\n<section data-region=\"content\"></section>\n\n```\n\n   now that you have your layout you should tell the builder to use it in people's pages so add the\n   layout property to the page object:\n\n```javascript\n['John','Jane','Dave','Mike']\n.forEach(function (person)\n{\n   page({ layout: 'sidebar', path: 'person/'+person.toLowerCase(), title: person });\n});\n```\n\n   as you can see the content of the layout is prepended to the body of the page (so that you can leave\n   the js at the end for instance). \n\n * Now that you have regions you can use them to place *blocks* and *templates*, lets add a sample peoples block to the page: create a *src/html/block/peoples.html* like this:\n\n```html\n\n <ul>\n   <li><a href=\"/person/john.html\">John</a></li>\n   <li><a href=\"/person/jane.html\">Jane</a></li>\n </ul>\n\n```\n\n  and tell the builder you want it in the sidebar region (time to indent a bit): \n\n```javascript\n['John','Jane','Dave','Mike']\n.forEach(function (person)\n{\n   page\n   ({ \n        layout: 'sidebar', \n        blocks: { sidebar: 'peoples' },\n        path: 'person/'+person.toLowerCase(),\n        title: person \n   });\n});\n```\n\n  the syntax is:\n\n<pre>\n    blocks: { region: 'block' }\n</pre>\n\n  or of course (to place multiple blocks in order)\n\n<pre>\n    blocks: { region1: ['block1','block2',...], region2: ... }\n</pre>\n\n * so blocks are almost always static pieces of html that you want to reuse in various pages,\n   while templates are somenthing you use to render data, lets add template rendered after the peoples\n   block, create *src/html/template/person-menu.html*:\n\n```html\n\n    <ul>\n    {{for people}}\n     <li><a href=\"\">{{>#data}}</a></li>\n    {{/for}}\n    </ul>\n\n```\n\n   and place it after the block calling the *template* function:\n\n\n```javascript\nvar people= ['John','Jane','Dave','Mike'];\n\npeople.forEach(function (person)\n{\n   page\n   ({ \n       layout: 'sidebar', \n       blocks: { sidebar: ['peoples', template('person-menu',{ people: people })] },\n       path: 'person/'+person.toLowerCase(),\n       title: person\n   });\n});\n```\n\n  as you see we left the href attribute blank, wouldn't it be nice to have single place where\n  i create urls for a page? Yes, so:\n\n```javascript\nvar people= ['John','Jane','Dave','Mike'],\n    href= function (person)\n    {\n       return 'person/'+person.toLowerCase();\n    };\n\npeople.forEach(function (person)\n{\n   page\n   ({ \n       layout: 'sidebar', \n       blocks: { sidebar: ['peoples', template('person-menu',{ people: people })] },\n       path: href(person),\n       href: href, // tell the builder to use this function to build hrefs to this page type\n       title: person\n   });\n});\n```\n\n   and now i can use the href converter in the template:\n\n\n```html \n\n    <ul>\n    {{for people}}\n     <li><a href=\"{{:~href('person',#data)}}\">{{>#data}}</a></li>\n    {{/for}}\n    </ul>\n\n```\n \n   and voilà in any template that renders a person i can link it.. \n   \n   You can also use a *postBuild* hook to modify generator results:\n\n```javascript\nvar people= ['John','Jane','Dave','Mike'],\n    href= function (person)\n    {\n       return 'person/'+person.toLowerCase();\n    };\n\npeople.forEach(function (person)\n{\n   page\n   ({ \n       layout: 'sidebar', \n       blocks: { sidebar: ['peoples', template('person-menu',{ people: people })] },\n       path: href(person),\n       href: href, // tell the builder to use this function to build hrefs to this page type\n       title: person,\n       postBuild: function ($) // this function is serialized and sent to builder processes\n       {\n          $('body').addClass(this.person); // so you have to put any data in the page object to reference it\n       }\n   });\n});\n```\n\n## A step back (lifecycle)\n\nThe main idea behind this module is to get the data from some kind of legacy system,\ntransform it and render the data to html pages. So ideally you would have this lifecycle phases:\n\n* download: get the data from all the sources you need and place it in JSON format inside *data/json/<any>.json*\n* transform: transform all the json files that you imported in the most usefull form to generate your pages\n* render: generate the html from those data\n* postBuild: manipulate and arrange the generated html to fit your needs\n* deploy: push your html/css/js on some CDN\n\nHow to perform those phases? (generally)\n\n* download: write any kind of code that reads your data sources and writes json files into the *data/json/* directory, you can even use asynchronous transformations to perform this task.\n* transform: you can place javascript files under *src/js/transform/<any>.js* to declare transformations\n* render: use templates / region blocks and *src/js/page/<any>.js* to render your markup\n* postBuild: declare postBuild hooks and use jquery to modify the generated page markup.\n* deploy: use the grunt tasks for your CDN provider to push your dist directory on a CDN.\n\n## Parallel generation\n\nIn the render phase the grunt task forks 1 child for any core it finds on the machine where it is running.\nThose childs will then request jobs from a queue of pages to generate until all pages are generated, and the queue is emptied. To limit the number of builders you can configure the Gruntfile like this:\n\n```javascript\n  grunt.initConfig({\n    'html-builder': {\n          cpus: 2\n   ....\n```\n\n## JSON collections\n\nAny JSON file under *src/json/* or *data/json/* should contain a JSON array of objects. The *src/json/* directory\nis ment for initial collections / manually managed JSON collections (under SCM), where the *data/json/* directory is ment as the target directory for transformations (not under SCM). For example, in a company website, you could have a\n*src/json/persons.json* which contains:\n\n```javascript\n[{\n   name: 'John Doe',\n   role: 'CEO',\n   googleplusid: '1323221312'\n},\n{\n   name: 'Hipster Hacker',\n   role: 'CTO',\n   googleplusid: '31232143444'\n},\n{\n   name: 'Mark Hustler',\n   role: 'CFO',\n   googleplusid: '53453543534'\n}]\n```\n\nthis is from now on a *collection*. Collections are there to be transformed or rendered. For example, \nyou may want to integrate those info with what is present in the googleplus account of each person,\nto generate a more meaningful version of this collection in *data/json/persons.json*. This is what is,\ncalled a tranformation. Or you can use this collection in your page file:\n\n```javascript\nvar people= collection('persons'), // the collection function returns the corresponding javascript array of the json file\n    href= function (person)\n    {\n       return 'person/'+person.name.toLowerCase();\n    };\n\npeople.forEach(function (person)\n{\n   page\n   ({ \n       layout: 'sidebar', \n       blocks: { sidebar: ['peoples', template('person-menu',{ people: _.pluck(people,'name') })] },\n       path: href(person),\n       href: href, \n       title: person.name,\n       postBuild: function ($) \n       {\n          $('body').attr('data-googleplusid',this.person.googleplusid);\n       }\n   });\n});\n```\n\n\n## JSON transformations\n\nA transformation is a javascript file under *src/js/transform/*. For example *src/js/transform/google-profile.js*:\n\n```javascript\nasync(); // tells the framework that this is an asynchronous transformation\n\nvar request= prequire('request'), // prequire is a way to require your project modules instead of grunt-html-builder deps\n    config= grunt.config('google'), // you have access to grunt\n    profile= function (id,cb)\n    {\n            var json= '';\n\n            request.get('https://www.googleapis.com/plus/v1/people/'+id+'?key='+config.key,\n            function (err, res, body)\n            {\n               cb(JSON.parse(body));\n            });\n    };\n    \nvar profiles= [], log= grunt.log, _= grunt.util._;\n\ngrunt.util.async.forEachSeries(json, // inside any transformation you have a \"json\" variable, that is the collection you are transforming\nfunction (person,done)\n{\n                if (person.googleplusid)\n                  profile(person.googleplusid,function (p)\n                  {\n                          _.extend(person,{ title:    (p.organizations[0].title ? p.organizations[0].title : person.title),\n                                          aboutMe:  p.aboutMe });\n\n                          profiles.push(person);\n\n                          done();\n                      });\n                  });\n               else\n               {\n                  _.extend(person,{ foto: person.picture });\n                  profiles.push(person);\n                  done();\n               }\n},\nfunction (err)\n{\n   if (err)\n     done(err);\n   else\n     done(null,profiles);\n});\n```\n\nOnce you have a transformation file you can configure it to run in the *Gruntfile.js* like this:\n\n```javascript\n  grunt.initConfig({\n    'html-builder': {\n          json: [\n                     { collection: 'persons',  transform: 'google-profile', dest: 'persons' },\n                     ...\n                     { collection: 'persons',  transform: 'simple', dest: 'dummy' },\n                ]\n   ....\n```\n\nIn this case you have a \"complex\" transformation based on some asynchronous access to external resources.\nBut you can define simpler trasnformations like *src/js/transform/simple.js*:\n\n```javascript\n\njson.forEach(function (person, idx)\n{\n  person.seq= idx;\n});\n\ndone(json)\n\n```\n\nThis is a synchronous transform. The only difference is that you don't call async(), and the done function\nonly accepts one argument with the transformed collection.\n\n## XLSX transformations\n\nYou can use also xlsx files as a source by placing them in the *data/excel/* directory, and transforming them by:\n\n\n```javascript\n  grunt.initConfig({\n    'html-builder': {\n          json: [\n                     { excel: 'persons',  transform: 'google-profile', dest: 'persons' },\n                ]\n   ....\n```\n\nand the modified version of an ipothetical *google-profile.js*:\n\n```javascript\nasync(); // tells the framework that this is an asynchronous transformation\n\nvar request= prequire('request'), // prequire is a way to require your project modules instead of grunt-html-builder deps\n    config= grunt.config('google'), // you have access to grunt\n    profile= function (id,cb)\n    {\n            var json= '';\n\n            request.get('https://www.googleapis.com/plus/v1/people/'+id+'?key='+config.key,\n            function (err, res, body)\n            {\n               cb(JSON.parse(body));\n            });\n    };\n    \nvar workbook= json, profiles= [], log= grunt.log, _= grunt.util._,\n    persons= workbook.sheet('Persons')\n                     .toJSON(['name', // xlsx columns to object attributes (position / attribute name)\n                              'role'],\n                              function (p) { /*alter p as you whish*/ if (valid) return p; else return undefined; });\n\n\n\ngrunt.util.async.forEachSeries(persons, // inside any transformation you have a \"json\" variable, that is the collection you are transforming\nfunction (person,done)\n{\n                if (person.googleplusid)\n                  profile(person.googleplusid,function (p)\n                  {\n                          _.extend(person,{ title:    (p.organizations[0].title ? p.organizations[0].title : person.title),\n                                          aboutMe:  p.aboutMe });\n\n                          profiles.push(person);\n\n                          done();\n                      });\n                  });\n               else\n               {\n                  _.extend(person,{ foto: person.picture });\n                  profiles.push(person);\n                  done();\n               }\n},\nfunction (err)\n{\n   if (err)\n     done(err);\n   else\n     done(null,profiles);\n});\n```\n\n## index / mindex\n\nWhen transoforming large amounts of data you may find convenint to use *index* or *mindex* functions.\nSuppose you are transforming a long list of persons and you have a \"knows\" array that contains ids for\npersons that the current person knows, but you want the complete object in place instead of only the id:\nYou may:\n\n```javascript\n\njson.forEach(function (person)\n{\n\n    person.knows.forEach(function (id,idx)\n    {\n      person.knows[idx]= _.findWhere(json,{ id: id });\n    });\n\n});\n\ndone(json);\n\n```\n\nWhile this will work, it will not be very fast... Because you are scanning the json array N times for each person,\nto transform. A better approach would be:\n\n```javascript\n\nvar _person= index(json,'id');\n\njson.forEach(function (person)\n{\n\n    person.knows.forEach(function (id,idx)\n    {\n      person.knows[idx]= _person(id);\n    });\n\n});\n\ndone(json);\n\n```\n\nThis time it will be really faster, because the index function will create an *index* (_person) looping 1 time on the json array, when you call * _person* it will access an object by key returning you the result much faster.\n\nThe index function is ment for unique indexes (like ids), while the mindex function is ment for non-unique indexes,\nlike:\n\n```javascript\n\nvar _persons= mindex(json,'name');\n\njson.forEach(function (person)\n{\n\n    person.manyJohn= _persons('John');\n\n});\n\ndone(json);\n\n```\n\nwhere you can have multiple results for one index key, so the result is an array.\n\n## Multi language support\n\nYou can enable multi-language support by defining the languages propoerty in the Gruntfile configuration, like this:\n```javascript\n  grunt.initConfig({\n    'html-builder': {\n          languages: ['en','it','es','fr']\n   ....\n```\nthis means that the default language for the site is English (the first), and you have some alternative language.\nFrom now on the builder will create 4 html files for every path you define in a page file, for example:\n<pre>\nindex.html\nit/index.html\nes/index.html\nfr/index.html\n</pre>\n\nAs you can see the default language has no prefix whether all other languages are prefixed with the prefix you specified in the *languages* array. We encourage you to use [standards](http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\nHo you switch between languages is up to your implementation: you just need to link the current path with the right prefix.\n\nOnce you configured the *languages* array, you can use the *t* converter in your templates, to translate data or strings:\n```html\n\n    <p>This is a translated string: {{t:'Hello world'}}</p>\n\n    <p>This is a translated object property: {{t:role}}</p>\n    \n```\n\nIn order to get your data translated you should define special object properties keyed by language like this:\n```javascript\n\n[{\n     name: 'John Doe',\n     role: {\n               en: 'Sales',\n               it: 'Vendite',\n               es: 'Venta',\n               fr: 'Ventes'\n           }\n}]\n\n```\n\nwhile to get strings translated you should define a special collection *src/json/i18n.json*, like this:\n```javascript\n\n{\n     \"Hello world\":  {\n                           it: 'Ciao mondo',\n                           es: 'Hola mundo',\n                           fr: 'Bonjour tout le monde'\n                     }\n}\n\n```\n\nThat is actually JSON object where the default language string is the key, and the value is an object keyed by\nalternative languages.\n\n\n\n\n** ... doc in progress ...**\n\nThings to document:\n* html html\n* html layouts / regions\n* html blocks\n* html templates (jsrender)\n* client files (images,css,js...)\n* filtering pages\n* s3 / cloudfront deploy\n* RDF / jsonld support\n\n## Release History\n* 2013-05-15   v0.4.20   First documented BETA release\n\n## License\nCopyright (c) 2013 Andrea Amerigo Aristodemo Gariboldi  \nLicensed under the Apache2 license.\n\n\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/aaaristo/grunt-html-builder/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\n\n",
  "readmeFilename": "README.md",
  "_id": "grunt-html-builder@0.5.8",
  "dist": {
    "shasum": "083551342714afc2a6b190a1ad9535634eb81a06"
  },
  "_from": "grunt-html-builder@",
  "_resolved": "https://registry.npmjs.org/grunt-html-builder/-/grunt-html-builder-0.5.8.tgz"
}
